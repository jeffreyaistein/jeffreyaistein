"""
Jeffrey AIstein - Output Style Rewriter

Applies derived style rules to rewrite outputs for X platform.
Uses style_guide.json generated by the style dataset pipeline.

Supports loading from:
1. Database (active style_guide_versions row)
2. Proposal JSON files (from json_path)
3. Baseline style_guide.json (fallback)

HARD BRAND RULES (non-negotiable):
- NEVER output emojis (anywhere: web, X drafts, replies, timeline posts)
- NEVER output hashtags (anywhere: web, X drafts, replies, timeline posts)

Safety Invariants:
- All loaded guides MUST contain hard_constraints.emojis_allowed=0
- All loaded guides MUST contain hard_constraints.hashtags_allowed=0
- If validation fails, refuse to load and keep last-known-good guide
"""

import json
import re
import threading
from pathlib import Path
from typing import Optional

import structlog

logger = structlog.get_logger()

# Comprehensive emoji pattern matching
# Covers: emoticons, dingbats, symbols, pictographs, transport, flags, etc.
EMOJI_PATTERN = re.compile(
    "["
    "\U0001F600-\U0001F64F"  # Emoticons
    "\U0001F300-\U0001F5FF"  # Misc Symbols and Pictographs
    "\U0001F680-\U0001F6FF"  # Transport and Map
    "\U0001F700-\U0001F77F"  # Alchemical Symbols
    "\U0001F780-\U0001F7FF"  # Geometric Shapes Extended
    "\U0001F800-\U0001F8FF"  # Supplemental Arrows-C
    "\U0001F900-\U0001F9FF"  # Supplemental Symbols and Pictographs
    "\U0001FA00-\U0001FA6F"  # Chess Symbols
    "\U0001FA70-\U0001FAFF"  # Symbols and Pictographs Extended-A
    "\U00002702-\U000027B0"  # Dingbats
    "\U000024C2-\U0001F251"  # Enclosed characters
    "\U0001F1E0-\U0001F1FF"  # Flags (iOS)
    "\U00002300-\U000023FF"  # Misc Technical
    "\U00002600-\U000026FF"  # Misc Symbols
    "\U00002700-\U000027BF"  # Dingbats
    "\U0000FE00-\U0000FE0F"  # Variation Selectors
    "\U0001F000-\U0001F02F"  # Mahjong Tiles
    "\U0001F0A0-\U0001F0FF"  # Playing Cards
    "]+",
    flags=re.UNICODE,
)

# Hashtag pattern
HASHTAG_PATTERN = re.compile(r"#\w+", re.UNICODE)

# Default style guide location
STYLE_GUIDE_PATH = Path(__file__).parent / "style_guide.json"


def _validate_hard_constraints(guide: dict) -> tuple[bool, str]:
    """
    Validate that a guide contains required hard constraints.

    Returns:
        Tuple of (is_valid, error_message)
    """
    hard_constraints = guide.get("hard_constraints", {})

    emojis_allowed = hard_constraints.get("emojis_allowed")
    if emojis_allowed != 0:
        return False, f"hard_constraints.emojis_allowed must be 0, got {emojis_allowed}"

    hashtags_allowed = hard_constraints.get("hashtags_allowed")
    if hashtags_allowed != 0:
        return False, f"hard_constraints.hashtags_allowed must be 0, got {hashtags_allowed}"

    return True, ""


class StyleRewriter:
    """
    Rewrites outputs to match derived KOL style patterns.

    Applied when generating content for X (Twitter) platform.

    Supports:
    - Loading active version from database
    - Hot reload without restart
    - Fallback to baseline if no active version
    - Safety validation of hard constraints
    """

    def __init__(
        self,
        style_guide_path: Optional[Path] = None,
        use_database: bool = True,
    ):
        """
        Initialize the rewriter.

        Args:
            style_guide_path: Path to baseline style_guide.json
            use_database: Whether to attempt loading from DB first
        """
        self.baseline_path = style_guide_path or STYLE_GUIDE_PATH
        self.use_database = use_database

        # Current state
        self.guide: Optional[dict] = None
        self._active_version_id: Optional[str] = None
        self._guide_source: str = "none"  # "database", "file", "baseline", "none"

        # Concurrency lock for reload
        self._lock = threading.Lock()

        # Load initial guide
        self._load_guide()

    def _load_from_database(self) -> Optional[tuple[dict, str]]:
        """
        Load active style guide from database.

        Returns:
            Tuple of (guide_dict, version_id) or None if not available
        """
        try:
            # Import here to avoid circular imports and allow running without DB
            import asyncio
            from sqlalchemy import text

            # Check if we're in an async context
            try:
                loop = asyncio.get_running_loop()
            except RuntimeError:
                loop = None

            if loop is not None:
                # We're in an async context - can't use sync DB call
                # This will be handled by reload_async()
                logger.debug("style_rewriter_in_async_context", msg="skipping sync DB load")
                return None

            # Import DB session
            from db.base import async_session_maker

            async def _fetch_active():
                async with async_session_maker() as session:
                    result = await session.execute(
                        text("""
                            SELECT version_id, json_path, metadata_json
                            FROM style_guide_versions
                            WHERE is_active = true
                            LIMIT 1
                        """)
                    )
                    row = result.mappings().fetchone()
                    return row

            row = asyncio.run(_fetch_active())

            if not row:
                logger.debug("style_rewriter_no_active_version")
                return None

            version_id = row["version_id"]
            json_path = row["json_path"]

            # Load JSON from file path
            json_file = Path(json_path)
            if not json_file.is_absolute():
                # Relative path - resolve from project root
                json_file = Path(__file__).parent.parent.parent / json_path

            if not json_file.exists():
                logger.error(
                    "style_guide_file_not_found",
                    version_id=version_id,
                    path=str(json_file),
                )
                return None

            with open(json_file, "r", encoding="utf-8") as f:
                guide = json.load(f)

            return guide, version_id

        except ImportError as e:
            logger.debug("style_rewriter_db_import_failed", error=str(e))
            return None
        except Exception as e:
            logger.error("style_rewriter_db_load_failed", error=str(e))
            return None

    def _load_from_baseline(self) -> Optional[dict]:
        """Load baseline style guide from file."""
        if not self.baseline_path.exists():
            logger.warning(
                "style_guide_baseline_not_found",
                path=str(self.baseline_path),
            )
            return None

        try:
            with open(self.baseline_path, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception as e:
            logger.error("style_guide_baseline_load_failed", error=str(e))
            return None

    def _load_guide(self) -> None:
        """
        Load style guide with fallback chain.

        Order:
        1. Database (active version) if use_database=True
        2. Baseline file (style_guide.json)

        Validates hard constraints before accepting any guide.
        If validation fails, continues to next option in fallback chain.
        """
        with self._lock:
            # Keep track of previous state for rollback
            previous_guide = self.guide
            previous_version_id = self._active_version_id
            previous_source = self._guide_source

            db_failed_validation = False

            # Try database first
            if self.use_database:
                db_result = self._load_from_database()
                if db_result:
                    guide, version_id = db_result

                    # Validate hard constraints
                    is_valid, error = _validate_hard_constraints(guide)
                    if not is_valid:
                        logger.error(
                            "style_guide_validation_failed",
                            version_id=version_id,
                            error=error,
                            action="refusing to load, trying baseline",
                        )
                        db_failed_validation = True
                        # Continue to baseline fallback
                    else:
                        # Valid - use this guide
                        self.guide = guide
                        self._active_version_id = version_id
                        self._guide_source = "database"
                        logger.info(
                            "style_guide_loaded_from_db",
                            version_id=version_id,
                        )
                        return

            # Fallback to baseline
            baseline = self._load_from_baseline()
            if baseline:
                # Validate hard constraints
                is_valid, error = _validate_hard_constraints(baseline)
                if not is_valid:
                    logger.error(
                        "style_guide_baseline_validation_failed",
                        error=error,
                        action="keeping previous or none",
                    )
                    # Keep previous guide if we have one
                    if previous_guide:
                        self.guide = previous_guide
                        self._active_version_id = previous_version_id
                        self._guide_source = previous_source
                    return

                # Valid - use baseline
                self.guide = baseline
                self._active_version_id = None
                self._guide_source = "baseline"
                logger.info("style_guide_loaded_from_baseline", path=str(self.baseline_path))
                return

            # No guide available from any source
            if previous_guide:
                # Keep previous
                self.guide = previous_guide
                self._active_version_id = previous_version_id
                self._guide_source = previous_source
                logger.warning("style_guide_no_source_keeping_previous")
            else:
                self.guide = None
                self._active_version_id = None
                self._guide_source = "none"
                logger.warning("style_guide_not_available")

    def reload(self) -> bool:
        """
        Reload the style guide from source (database or baseline).

        Thread-safe: uses internal lock.
        Safe: keeps previous guide if loading fails.

        Returns:
            True if reload succeeded, False otherwise
        """
        previous_version = self._active_version_id
        previous_source = self._guide_source

        self._load_guide()

        changed = (
            self._active_version_id != previous_version
            or self._guide_source != previous_source
        )

        if changed:
            logger.info(
                "style_guide_reloaded",
                previous_version=previous_version,
                previous_source=previous_source,
                new_version=self._active_version_id,
                new_source=self._guide_source,
            )

        return self.guide is not None

    async def reload_async(self) -> bool:
        """
        Reload the style guide from database (async version).

        Use this when calling from an async context.

        Returns:
            True if reload succeeded, False otherwise
        """
        try:
            from sqlalchemy import text
            from db.base import async_session_maker

            async with async_session_maker() as session:
                result = await session.execute(
                    text("""
                        SELECT version_id, json_path, metadata_json
                        FROM style_guide_versions
                        WHERE is_active = true
                        LIMIT 1
                    """)
                )
                row = result.mappings().fetchone()

            if row:
                version_id = row["version_id"]
                json_path = row["json_path"]

                # Load JSON from file path
                json_file = Path(json_path)
                if not json_file.is_absolute():
                    json_file = Path(__file__).parent.parent.parent / json_path

                if not json_file.exists():
                    logger.error(
                        "style_guide_file_not_found_async",
                        version_id=version_id,
                        path=str(json_file),
                    )
                    return False

                with open(json_file, "r", encoding="utf-8") as f:
                    guide = json.load(f)

                # Validate hard constraints
                is_valid, error = _validate_hard_constraints(guide)
                if not is_valid:
                    logger.error(
                        "style_guide_validation_failed_async",
                        version_id=version_id,
                        error=error,
                    )
                    return False

                with self._lock:
                    self.guide = guide
                    self._active_version_id = version_id
                    self._guide_source = "database"

                logger.info("style_guide_loaded_from_db_async", version_id=version_id)
                return True

            # No active version - try baseline
            baseline = self._load_from_baseline()
            if baseline:
                is_valid, error = _validate_hard_constraints(baseline)
                if is_valid:
                    with self._lock:
                        self.guide = baseline
                        self._active_version_id = None
                        self._guide_source = "baseline"
                    logger.info("style_guide_loaded_from_baseline_async")
                    return True

            return self.guide is not None

        except Exception as e:
            logger.error("style_guide_reload_async_failed", error=str(e))
            return False

    def is_available(self) -> bool:
        """Check if style guide is loaded."""
        return self.guide is not None

    def get_active_version_id(self) -> Optional[str]:
        """Get the currently active version ID (None if using baseline)."""
        return self._active_version_id

    def get_guide_source(self) -> str:
        """Get the source of the current guide: 'database', 'baseline', or 'none'."""
        return self._guide_source

    def get_generated_at(self) -> Optional[str]:
        """Get the timestamp when the style guide was generated."""
        if not self.guide:
            return None
        return self.guide.get("generated_at")

    def get_target_length(self) -> int:
        """Get target tweet length from guide."""
        if not self.guide:
            return 200  # Default
        return self.guide.get("rewriting", {}).get("target_length", 200)

    def get_max_length(self) -> int:
        """Get max tweet length from guide."""
        if not self.guide:
            return 280
        return self.guide.get("rewriting", {}).get("max_length", 280)

    def get_avoid_patterns(self) -> list[str]:
        """Get patterns to avoid."""
        if not self.guide:
            return []
        return self.guide.get("rewriting", {}).get("avoid", [])

    def get_prefer_patterns(self) -> list[str]:
        """Get preferred patterns."""
        if not self.guide:
            return []
        return self.guide.get("rewriting", {}).get("prefer", [])

    def check_corporate_language(self, text: str) -> list[str]:
        """Check for corporate language to avoid."""
        corporate_patterns = [
            r"\bsynergy\b",
            r"\bleverag(e|ing)\b",
            r"\boptimiz(e|ing)\b",
            r"\bstakeholder\b",
            r"\baction(able)?\s+item\b",
            r"\bmove the needle\b",
            r"\bcircle back\b",
            r"\btouch base\b",
            r"\bdeep dive\b",
            r"\bpivot\b",
            r"\bscalable\b",
            r"\bproactive(ly)?\b",
            r"\bholistic\b",
            r"\binnovative\b",
            r"\bdisrupt(ive)?\b",
            r"\bempowerment\b",
        ]

        found = []
        text_lower = text.lower()
        for pattern in corporate_patterns:
            if re.search(pattern, text_lower):
                found.append(pattern.replace(r"\b", "").replace("\\", ""))

        return found

    def check_excessive_punctuation(self, text: str) -> bool:
        """Check for excessive exclamation marks."""
        exclaim_count = text.count("!")
        return exclaim_count > 2

    def check_hashtag_spam(self, text: str) -> bool:
        """Check for excessive hashtags."""
        hashtag_count = len(re.findall(r"#\w+", text))
        # Guide says hashtags are rare (<20%)
        return hashtag_count > 2

    @staticmethod
    def strip_emojis(text: str) -> str:
        """
        Remove ALL emojis from text.

        This is a HARD BRAND RULE - no emojis allowed anywhere.
        """
        return EMOJI_PATTERN.sub("", text)

    @staticmethod
    def strip_hashtags(text: str) -> str:
        """
        Remove ALL hashtags from text.

        This is a HARD BRAND RULE - no hashtags allowed anywhere.
        """
        return HASHTAG_PATTERN.sub("", text)

    @staticmethod
    def contains_emoji(text: str) -> bool:
        """Check if text contains any emoji."""
        return bool(EMOJI_PATTERN.search(text))

    @staticmethod
    def contains_hashtag(text: str) -> bool:
        """Check if text contains any hashtag."""
        return bool(HASHTAG_PATTERN.search(text))

    def validate_brand_rules(self, text: str) -> tuple[bool, list[str]]:
        """
        Validate that text conforms to hard brand rules.

        Returns:
            Tuple of (is_valid, list of violations)
        """
        violations = []

        if self.contains_emoji(text):
            violations.append("Contains emoji (forbidden)")

        if self.contains_hashtag(text):
            violations.append("Contains hashtag (forbidden)")

        return len(violations) == 0, violations

    def enforce_brand_rules(self, text: str) -> str:
        """
        Enforce hard brand rules by stripping forbidden content.

        Strips emojis and hashtags, cleans up whitespace.
        """
        result = text

        # Strip emojis
        result = self.strip_emojis(result)

        # Strip hashtags
        result = self.strip_hashtags(result)

        # Clean up resulting whitespace issues
        result = re.sub(r"\s+", " ", result)  # Multiple spaces to single
        result = result.strip()

        return result

    def suggest_improvements(self, text: str) -> list[str]:
        """
        Analyze text and suggest style improvements.

        Args:
            text: Input text to analyze

        Returns:
            List of improvement suggestions
        """
        suggestions = []

        # Length check
        if len(text) > self.get_target_length():
            suggestions.append(
                f"Consider shortening - target length is {self.get_target_length()} chars, got {len(text)}"
            )

        # Corporate language
        corporate = self.check_corporate_language(text)
        if corporate:
            suggestions.append(f"Avoid corporate language: {', '.join(corporate)}")

        # Punctuation
        if self.check_excessive_punctuation(text):
            suggestions.append("Reduce exclamation marks - KOLs use them sparingly")

        # Hashtags
        if self.check_hashtag_spam(text):
            suggestions.append("Reduce hashtags - KOLs rarely use them")

        # Check for guaranteed returns language
        guarantee_patterns = [
            r"\bguarantee\b",
            r"\b100%\b",
            r"\bcannot lose\b",
            r"\beasy money\b",
            r"\bfree money\b",
            r"\brisk.free\b",
        ]
        for pattern in guarantee_patterns:
            if re.search(pattern, text.lower()):
                suggestions.append("Avoid guarantee language - use 'nfa' and observations instead")
                break

        return suggestions

    def rewrite_for_x(self, text: str, aggressive: bool = False) -> str:
        """
        Rewrite text to match X style patterns.

        Applies HARD BRAND RULES:
        - Strips ALL emojis
        - Strips ALL hashtags
        - Validates after stripping

        Args:
            text: Input text to rewrite
            aggressive: If True, apply more aggressive shortening

        Returns:
            Rewritten text (guaranteed emoji-free and hashtag-free)
        """
        result = text.strip()

        # HARD BRAND RULES: Strip emojis and hashtags FIRST
        result = self.enforce_brand_rules(result)

        # Remove excessive exclamation marks
        while "!!" in result:
            result = result.replace("!!", "!")

        # Ensure under max length
        max_len = self.get_max_length()
        if len(result) > max_len:
            # Truncate with ellipsis
            result = result[: max_len - 3] + "..."

        # Remove multiple newlines
        while "\n\n\n" in result:
            result = result.replace("\n\n\n", "\n\n")

        # Aggressive mode: try to hit target length
        if aggressive and len(result) > self.get_target_length():
            # Remove trailing punctuation redundancy
            result = re.sub(r"[.!?]+$", ".", result)

        # Final validation - log if anything slipped through
        is_valid, violations = self.validate_brand_rules(result)
        if not is_valid:
            logger.error("brand_rule_violation_after_rewrite", violations=violations)
            # Emergency strip again
            result = self.enforce_brand_rules(result)

        return result

    def rewrite_for_web(self, text: str) -> str:
        """
        Rewrite text for web chat output.

        Applies HARD BRAND RULES (same as X):
        - Strips ALL emojis
        - Strips ALL hashtags

        Args:
            text: Input text to rewrite

        Returns:
            Rewritten text (guaranteed emoji-free and hashtag-free)
        """
        result = text.strip()

        # HARD BRAND RULES: Strip emojis and hashtags
        result = self.enforce_brand_rules(result)

        # Final validation
        is_valid, violations = self.validate_brand_rules(result)
        if not is_valid:
            logger.error("brand_rule_violation_after_web_rewrite", violations=violations)
            result = self.enforce_brand_rules(result)

        return result

    def get_style_context_for_prompt(self) -> str:
        """
        Get style context to inject into LLM prompts.

        Returns concise rules for content generation.
        """
        if not self.guide:
            return ""

        rules = self.guide.get("rules", [])
        if not rules:
            return ""

        context_parts = [
            "## X Platform Style (Derived from KOL Analysis)",
            "",
        ]

        for rule in rules[:5]:  # Top 5 rules
            context_parts.append(f"- {rule}")

        context_parts.extend([
            "",
            "Key constraints:",
            f"- Target length: {self.get_target_length()} chars",
            "- NEVER use hashtags - zero allowed, not even one",
            "- NEVER use emojis - zero allowed, no unicode emoji",
            "- Avoid: corporate language, excessive punctuation",
            "- Prefer: brevity, observations, self-aware humor",
            "",
        ])

        return "\n".join(context_parts)

    def get_status(self) -> dict:
        """Get current status for admin endpoints."""
        return {
            "available": self.is_available(),
            "source": self._guide_source,
            "active_version_id": self._active_version_id,
            "generated_at": self.get_generated_at(),
            "target_length": self.get_target_length(),
            "max_length": self.get_max_length(),
        }


# Singleton instance
_rewriter_instance: Optional[StyleRewriter] = None
_rewriter_lock = threading.Lock()


def get_style_rewriter() -> StyleRewriter:
    """Get or create the style rewriter singleton."""
    global _rewriter_instance
    with _rewriter_lock:
        if _rewriter_instance is None:
            _rewriter_instance = StyleRewriter()
        return _rewriter_instance


def reset_style_rewriter() -> None:
    """Reset the style rewriter singleton (for testing)."""
    global _rewriter_instance
    with _rewriter_lock:
        _rewriter_instance = None


def reload_style_rewriter() -> bool:
    """Reload the style rewriter singleton."""
    rewriter = get_style_rewriter()
    return rewriter.reload()


async def reload_style_rewriter_async() -> bool:
    """Reload the style rewriter singleton (async version)."""
    rewriter = get_style_rewriter()
    return await rewriter.reload_async()
